// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(cuid())
  walletAddress String   @unique
  email         String?  @unique
  githubId      String?  @unique
  githubUsername String?
  githubAccessToken String?
  honeycombUserId String? @unique
  displayName   String
  avatarUrl     String?
  bio           String?
  selectedKingdom String?
  role          UserRole @default(PLAYER)
  
  // Game Progress
  xpTotal         Int @default(0)
  reputationScore Int @default(0)
  skillScores     Json @default("{}")
  isVerified      Boolean @default(false)
  lastActive      DateTime @default(now())
  
  // Settings
  preferences     Json @default("{}")
  metadata        Json @default("{}")
  
  // Relationships
  teamMembers     TeamMember[]
  
  // Mission related
  submissions     Submission[] @relation("UserSubmissions")
  reviews         PeerReview[] @relation("ReviewerReviews")
  reviewerSubmissions Submission[] @relation("ReviewerSubmissions")
  
  // Challenge related
  challengerChallenges Challenge[] @relation("ChallengerChallenges")
  defenderChallenges Challenge[] @relation("DefenderChallenges")
  
  // Mentor related
  mentorProfile   Mentor?
  menteeUserSessions MentorSession[] @relation("MenteeUserSessions")
  mentorReviews   MentorReview[] @relation("MentorReviewer")
  
  // Sponsor related
  sponsorProfile  Sponsor?
  questSubmissions QuestSubmission[] @relation("UserQuestSubmissions")
  questReviews    QuestSubmission[] @relation("QuestReviewer")
  
  // Team related
  teamInvitations TeamInvitation[] @relation("InvitedUser")
  sentInvitations TeamInvitation[] @relation("InvitedByUser")
  initiatedSplits TeamSplit[] @relation("InitiatedSplits")
  mediatedSplits  TeamSplit[] @relation("MediatedSplits")
  
  // Progress
  badges          UserBadge[]
  traits          UserTrait[]
  nodeProgress    NodeProgress[]
  territories     Territory[] @relation("UserTerritories")
  
  // Character System
  character       FounderCharacter?
  resourceInventory UserResourceInventory[]
  craftingJobs    CraftingJob[]
  
  // Dispute resolution
  initiatedDisputes     TeamDispute[] @relation("DisputeInitiator")
  disputeVotes          DisputeVote[] @relation("DisputeVotes")
  proposedSeparations   TeamSeparation[] @relation("SeparationProposer")
  separationVotes       SeparationVote[] @relation("SeparationVotes")
  tokenTransactions     TokenTransaction[] @relation("TokenTransactions")
  
  // System
  auditLogs       AuditLog[]
  notifications   Notification[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Team {
  id            String   @id @default(cuid())
  name          String   @unique
  description   String?
  emblemUrl     String?
  foundedAt     DateTime @default(now())
  isActive      Boolean  @default(true)
  
  // Wallet & Treasury
  teamWallet    String?
  vaultBalance  Int @default(0)
  
  // Legal
  agreementId   String?
  
  // Stats
  totalXp       Int @default(0)
  memberCount   Int @default(0)
  completedMissions Int @default(0)
  territoriesOwned  Int @default(0)
  
  // Settings
  isPublic      Boolean @default(true)
  autoAcceptInvites Boolean @default(false)
  maxMembers    Int @default(8)
  
  metadata      Json @default("{}")
  
  // Relationships
  members       TeamMember[]
  agreement     FounderAgreement? @relation(fields: [agreementId], references: [id])
  
  // Mission related
  submissions   Submission[] @relation("TeamSubmissions")
  
  // Challenge related
  challengerChallenges Challenge[] @relation("TeamChallengerChallenges")
  defenderChallenges Challenge[] @relation("TeamDefenderChallenges")
  
  // Other relationships
  territories   Territory[] @relation("TeamTerritories")
  invitations   TeamInvitation[]
  splits        TeamSplit[]
  quests        TeamQuest[]
  menteeTeamSessions MentorSession[] @relation("MenteeTeamSessions")
  questSubmissions QuestSubmission[] @relation("TeamQuestSubmissions")
  disputes      TeamDispute[]
  separations   TeamSeparation[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("teams")
}

model TeamMember {
  id              String   @id @default(cuid())
  teamId          String
  userId          String
  role            TeamRole @default(DEVELOPER)
  joinedAt        DateTime @default(now())
  isActive        Boolean  @default(true)
  equity          Float?
  contributionScore Int    @default(0)
  permissions     Json     @default("{}")
  
  // Relationships
  team            Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teamId, userId])
  @@map("team_members")
}

model FounderAgreement {
  id              String   @id @default(cuid())
  teamId          String
  version         Int      @default(1)
  content         String   // Legal document content
  ipfsHash        String?  // IPFS hash of the document
  onchainTxHash   String?  // Solana transaction hash
  
  // Agreement Terms
  terms           Json
  
  // Signatures
  signatures      Json @default("[]")
  isFullySigned   Boolean @default(false)
  
  // Status
  status          AgreementStatus @default(DRAFT)
  
  metadata        Json @default("{}")
  
  // Relationships
  teams           Team[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("founder_agreements")
}

model TeamInvitation {
  id              String   @id @default(cuid())
  teamId          String
  invitedUserId   String
  invitedByUserId String
  proposedRole    TeamRole @default(DEVELOPER)
  proposedEquity  Float?
  message         String?
  status          InvitationStatus @default(PENDING)
  expiresAt       DateTime
  
  // Relationships
  team            Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  invitedUser     User @relation("InvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)
  invitedBy       User @relation("InvitedByUser", fields: [invitedByUserId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("team_invitations")
}

model TeamSplit {
  id              String   @id @default(cuid())
  teamId          String
  initiatedByUserId String
  reason          String
  status          SplitStatus @default(PROPOSED)
  
  // Split terms
  proposedSplit   Json
  votes           Json @default("[]")
  mediatorId      String?
  
  // Asset settlement
  assetDistribution Json @default("[]")
  finalizedAt     DateTime?
  
  // Relationships
  team            Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  initiatedBy     User @relation("InitiatedSplits", fields: [initiatedByUserId], references: [id])
  mediator        User? @relation("MediatedSplits", fields: [mediatorId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("team_splits")
}

model GameMap {
  id              String   @id @default(cuid())
  name            String   @unique
  description     String
  skillTag        String
  backgroundImageUrl String?
  isActive        Boolean  @default(true)
  order           Int
  prerequisites   Json     @default("[]")
  metadata        Json     @default("{}")
  
  // Relationships
  nodes           MapNode[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("game_maps")
}

model MapNode {
  id              String   @id @default(cuid())
  mapId           String
  title           String
  description     String
  position        Json     // {x, y} coordinates
  difficulty      Difficulty
  nodeType        NodeType
  order           Int
  estimatedTime   Int      // minutes
  isLocked        Boolean  @default(true)
  isPvpEnabled    Boolean  @default(false)
  sponsorId       String?
  
  // Requirements
  prerequisites   Json     @default("[]")
  artifactRequirements Json @default("[]")
  
  // Rewards
  rewards         Json
  
  // Content
  content         Json
  
  // State
  completionCount Int      @default(0)
  averageRating   Float    @default(0)
  metadata        Json     @default("{}")
  
  // Relationships
  map             GameMap @relation(fields: [mapId], references: [id], onDelete: Cascade)
  sponsor         Sponsor? @relation(fields: [sponsorId], references: [id])
  missions        Mission[]
  challenges      Challenge[]
  territories     Territory[]
  progress        NodeProgress[]
  sponsorQuests   SponsorQuest[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("map_nodes")
}

model Mission {
  id              String   @id @default(cuid())
  nodeId          String
  honeycombMissionId String?
  name            String
  description     String
  objectives      Json     @default("[]")
  requirements    Json     @default("[]")
  rewards         Json
  timeLimit       Int?     // minutes
  maxAttempts     Int?
  isActive        Boolean  @default(true)
  metadata        Json     @default("{}")
  
  // Relationships
  node            MapNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  submissions     Submission[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("missions")
}

model Submission {
  id              String   @id @default(cuid())
  missionId       String
  submitterType   SubmitterType
  submitterId     String   // User or Team ID
  status          SubmissionStatus @default(SUBMITTED)
  score           Int?
  maxScore        Int
  
  // Artifacts
  artifacts       Json     @default("[]")
  
  // Review
  reviewerId      String?
  reviewNotes     String?
  reviewedAt      DateTime?
  
  // Verification
  verificationResults Json @default("[]")
  honeycombResult Json?
  
  // Attempt tracking
  attemptNumber   Int      @default(1)
  timeSpent       Int      @default(0) // seconds
  
  metadata        Json     @default("{}")
  
  // Relationships
  mission         Mission @relation(fields: [missionId], references: [id], onDelete: Cascade)
  submitterUser   User? @relation("UserSubmissions", fields: [submitterId], references: [id], map: "submissions_submitter_user_fkey")
  submitterTeam   Team? @relation("TeamSubmissions", fields: [submitterId], references: [id], map: "submissions_submitter_team_fkey")
  reviewer        User? @relation("ReviewerSubmissions", fields: [reviewerId], references: [id])
  reviews         PeerReview[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("submissions")
}

model PeerReview {
  id              String   @id @default(cuid())
  submissionId    String
  reviewerId      String
  score           Int
  maxScore        Int
  feedback        Json
  status          ReviewStatus @default(PENDING)
  timeSpent       Int      @default(0) // seconds
  
  // Relationships
  submission      Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  reviewer        User @relation("ReviewerReviews", fields: [reviewerId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([submissionId, reviewerId])
  @@map("peer_reviews")
}

model Challenge {
  id              String   @id @default(cuid())
  nodeId          String
  challengerId    String
  defenderId      String
  challengerType  SubmitterType
  defenderType    SubmitterType
  
  // Challenge details
  type            ChallengeType
  stakeAmount     Int?
  description     String
  
  // Status
  status          ChallengeStatus @default(PENDING)
  
  // Timing
  acceptDeadline  DateTime
  submissionDeadline DateTime?
  
  // Submissions
  challengerSubmissionId String?
  defenderSubmissionId   String?
  
  // Judging
  judges          Json     @default("[]")
  verdict         Json?
  
  metadata        Json     @default("{}")
  
  // Relationships
  node            MapNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  challengerUser  User? @relation("ChallengerChallenges", fields: [challengerId], references: [id], map: "challenges_challenger_user_fkey")
  defenderUser    User? @relation("DefenderChallenges", fields: [defenderId], references: [id], map: "challenges_defender_user_fkey")
  challengerTeam  Team? @relation("TeamChallengerChallenges", fields: [challengerId], references: [id], map: "challenges_challenger_team_fkey")
  defenderTeam    Team? @relation("TeamDefenderChallenges", fields: [defenderId], references: [id], map: "challenges_defender_team_fkey")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("challenges")
}

model Sponsor {
  id              String   @id @default(cuid())
  userId          String   @unique
  organizationName String
  contactEmail    String
  contactName     String
  website         String?
  logoUrl         String?
  description     String
  
  // Blockchain
  sponsorWallet   String
  balance         Int      @default(0)
  
  // Branding
  brandColors     Json     @default("{}")
  brandAssets     Json     @default("{}")
  
  // Settings
  isActive        Boolean  @default(true)
  tier            SponsorTier @default(BRONZE)
  
  // Stats
  totalQuestsCreated      Int @default(0)
  totalRewardsDistributed Int @default(0)
  totalParticipants       Int @default(0)
  averageCompletion       Float @default(0)
  
  metadata        Json     @default("{}")
  
  // Relationships
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  nodes           MapNode[]
  quests          SponsorQuest[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sponsors")
}

model SponsorQuest {
  id              String   @id @default(cuid())
  sponsorId       String
  nodeId          String?  // If attached to existing node
  
  // Basic info
  title           String
  description     String
  objectives      Json     @default("[]")
  
  // Constraints
  maxParticipants Int?
  startDate       DateTime
  endDate         DateTime
  isActive        Boolean  @default(true)
  
  // Requirements
  requirements    Json     @default("[]")
  eligibilityCriteria Json @default("{}")
  
  // Rewards
  rewardPool      Json
  rewardDistribution Json
  
  // Verification
  verificationMethod VerificationMethod @default(AUTOMATIC)
  reviewers       Json     @default("[]")
  
  // Analytics
  participantCount Int     @default(0)
  completionCount Int      @default(0)
  totalRewardsDistributed Int @default(0)
  
  metadata        Json     @default("{}")
  
  // Relationships
  sponsor         Sponsor @relation(fields: [sponsorId], references: [id], onDelete: Cascade)
  node            MapNode? @relation(fields: [nodeId], references: [id])
  submissions     QuestSubmission[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sponsor_quests")
}

model QuestSubmission {
  id              String   @id @default(cuid())
  questId         String
  participantId   String
  participantType SubmitterType
  
  // Submission data
  artifacts       Json     @default("[]")
  description     String
  
  // Scoring
  score           Int?
  maxScore        Int
  objectiveScores Json     @default("[]")
  
  // Review
  status          SubmissionStatus @default(SUBMITTED)
  reviewerId      String?
  reviewNotes     String?
  reviewedAt      DateTime?
  
  // Verification
  verificationResults Json @default("[]")
  automatedScore  Int?
  manualScore     Int?
  
  metadata        Json     @default("{}")
  
  // Relationships
  quest           SponsorQuest @relation(fields: [questId], references: [id], onDelete: Cascade)
  participantUser User? @relation("UserQuestSubmissions", fields: [participantId], references: [id], map: "quest_submissions_participant_user_fkey")
  participantTeam Team? @relation("TeamQuestSubmissions", fields: [participantId], references: [id], map: "quest_submissions_participant_team_fkey")
  reviewer        User? @relation("QuestReviewer", fields: [reviewerId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quest_submissions")
}

model Mentor {
  id              String   @id @default(cuid())
  userId          String   @unique
  
  // Professional info
  title           String
  company         String?
  bio             String
  linkedinUrl     String?
  twitterUrl      String?
  websiteUrl      String?
  
  // Expertise
  specialties     Json     @default("[]")
  skillAreas      Json     @default("[]")
  experienceLevel ExperienceLevel @default(JUNIOR)
  yearsOfExperience Int
  
  // Availability
  isAvailable     Boolean  @default(true)
  availableSlots  Json     @default("[]")
  timezone        String
  
  // Pricing
  hourlyRate      Int
  currency        Currency @default(USD)
  acceptsMentorTokens Boolean @default(true)
  mentorTokenRate Int?
  
  // Ratings & Reviews
  averageRating   Float    @default(0)
  totalReviews    Int      @default(0)
  totalSessions   Int      @default(0)
  responseTime    Int      @default(24) // hours
  
  // Settings
  maxSessionsPerWeek Int   @default(10)
  sessionDuration Json     @default("[60]")
  advanceBookingDays Int   @default(7)
  
  // Verification
  isVerified      Boolean  @default(false)
  verificationBadges Json  @default("[]")
  
  metadata        Json     @default("{}")
  
  // Relationships
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessions        MentorSession[] @relation("MentorSessions")
  reviews         MentorReview[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("mentors")
}

model MentorSession {
  id              String   @id @default(cuid())
  mentorId        String
  menteeId        String
  menteeType      SubmitterType
  
  // Session details
  title           String
  description     String
  category        String
  duration        Int      // minutes
  scheduledAt     DateTime
  
  // Status
  status          SessionStatus @default(SCHEDULED)
  
  // Communication
  meetingUrl      String?
  meetingPlatform String   @default("zoom")
  
  // Payment
  cost            Int
  paymentMethod   PaymentMethod @default(TOKENS)
  paymentStatus   PaymentStatus @default(PENDING)
  paymentTx       String?
  
  // Content
  agenda          Json     @default("[]")
  notes           String?
  resources       Json     @default("[]")
  actionItems     Json     @default("[]")
  
  // Follow-up
  followUpScheduled DateTime?
  followUpNotes   String?
  
  metadata        Json     @default("{}")
  
  // Relationships
  mentor          Mentor @relation("MentorSessions", fields: [mentorId], references: [id], onDelete: Cascade)
  menteeUser      User? @relation("MenteeUserSessions", fields: [menteeId], references: [id], map: "mentor_sessions_mentee_user_fkey")
  menteeTeam      Team? @relation("MenteeTeamSessions", fields: [menteeId], references: [id], map: "mentor_sessions_mentee_team_fkey")
  review          MentorReview?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("mentor_sessions")
}

model MentorReview {
  id              String   @id @default(cuid())
  sessionId       String   @unique
  mentorId        String
  reviewerId      String
  
  // Ratings (1-5 scale)
  overallRating   Int
  communicationRating Int
  knowledgeRating Int
  helpfulnessRating Int
  professionalism Int
  
  // Feedback
  review          String
  highlights      Json     @default("[]")
  improvements    Json     @default("[]")
  wouldRecommend  Boolean  @default(true)
  
  // Session evaluation
  sessionGoalsMet Boolean  @default(true)
  valueReceived   String   @default("met")
  
  // Visibility
  isPublic        Boolean  @default(true)
  isVerified      Boolean  @default(false)
  
  metadata        Json     @default("{}")
  
  // Relationships
  session         MentorSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  mentor          Mentor @relation(fields: [mentorId], references: [id], onDelete: Cascade)
  reviewer        User @relation("MentorReviewer", fields: [reviewerId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("mentor_reviews")
}

model UserBadge {
  id              String   @id @default(cuid())
  userId          String
  name            String
  description     String
  imageUrl        String
  rarity          BadgeRarity @default(COMMON)
  earnedAt        DateTime @default(now())
  metadata        Json     @default("{}")
  
  // Relationships
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_badges")
}

model UserTrait {
  id              String   @id @default(cuid())
  userId          String
  key             String
  name            String
  level           Int      @default(1)
  maxLevel        Int      @default(7)
  description     String
  honeycombTraitId String?
  metadata        Json     @default("{}")
  
  // Relationships
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
  @@map("user_traits")
}

model NodeProgress {
  id              String   @id @default(cuid())
  nodeId          String
  userId          String
  status          ProgressStatus @default(LOCKED)
  score           Int?
  completedAt     DateTime?
  attempts        Int      @default(0)
  timeSpent       Int      @default(0) // seconds
  lastAttemptAt   DateTime @default(now())
  
  // Relationships
  node            MapNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([nodeId, userId])
  @@map("node_progress")
}

model Territory {
  id              String   @id @default(cuid())
  nodeId          String
  controllerId    String
  controllerType  SubmitterType
  controlledAt    DateTime @default(now())
  expiresAt       DateTime?
  defenseCount    Int      @default(0)
  metadata        Json     @default("{}")
  
  // Relationships
  node            MapNode @relation(fields: [nodeId], references: [id], onDelete: Cascade)
  controllerUser  User? @relation("UserTerritories", fields: [controllerId], references: [id], map: "territories_controller_user_fkey")
  controllerTeam  Team? @relation("TeamTerritories", fields: [controllerId], references: [id], map: "territories_controller_team_fkey")
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([nodeId])
  @@map("territories")
}

// Team dispute resolution models
model TeamDispute {
  id                String   @id @default(cuid())
  teamId            String
  initiatorId       String
  disputeType       DisputeType
  description       String
  proposedResolution String
  status            DisputeStatus @default(OPEN)
  evidenceUrls      String[]
  affectedMembers   String[]
  votingDeadline    DateTime
  resolvedAt        DateTime?
  resolutionDetails Json?
  
  // Relationships
  team              Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  initiator         User @relation("DisputeInitiator", fields: [initiatorId], references: [id])
  votes             DisputeVote[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("team_disputes")
}

model DisputeVote {
  id        String @id @default(cuid())
  disputeId String
  userId    String
  vote      VoteType
  comments  String?
  
  // Relationships
  dispute   TeamDispute @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  user      User @relation("DisputeVotes", fields: [userId], references: [id])
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([disputeId, userId])
  @@map("dispute_votes")
}

model TeamSeparation {
  id                String   @id @default(cuid())
  teamId            String
  proposedBy        String
  separationType    SeparationType
  assetDistribution Json // Contains XP, resources, tokens allocation
  timeline          Int // Days to complete
  status            SeparationStatus @default(PENDING_VOTES)
  votingDeadline    DateTime
  termsAcceptance   Json // userId -> boolean mapping
  executedAt        DateTime?
  executionResults  Json?
  
  // Relationships
  team              Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  proposer          User @relation("SeparationProposer", fields: [proposedBy], references: [id])
  votes             SeparationVote[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("team_separations")
}

model SeparationVote {
  id           String @id @default(cuid())
  separationId String
  userId       String
  vote         VoteType
  comments     String?
  
  // Relationships
  separation   TeamSeparation @relation(fields: [separationId], references: [id], onDelete: Cascade)
  user         User @relation("SeparationVotes", fields: [userId], references: [id])
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([separationId, userId])
  @@map("separation_votes")
}

model TokenTransaction {
  id          String @id @default(cuid())
  userId      String
  amount      Decimal @db.Decimal(18, 8)
  type        TokenTransactionType
  status      TransactionStatus @default(PENDING)
  txHash      String?
  metadata    Json @default("{}")
  
  // Relationships
  user        User @relation("TokenTransactions", fields: [userId], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("token_transactions")
}

model TeamQuest {
  id              String   @id @default(cuid())
  teamId          String
  nodeId          String
  startedAt       DateTime @default(now())
  completedAt     DateTime?
  status          QuestStatus @default(ACTIVE)
  progress        Json     @default("{}")
  contributions   Json     @default("[]")
  
  // Relationships
  team            Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("team_quests")
}

model Notification {
  id              String   @id @default(cuid())
  userId          String
  type            NotificationType
  title           String
  message         String
  data            Json     @default("{}")
  isRead          Boolean  @default(false)
  
  // Relationships
  user            User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("notifications")
}

model AuditLog {
  id              String   @id @default(cuid())
  eventType       String
  resourceId      String
  actorId         String?
  metadata        Json     @default("{}")
  ipAddress       String?
  userAgent       String?
  
  // Relationships
  actor           User? @relation(fields: [actorId], references: [id])
  
  createdAt DateTime @default(now())

  @@map("audit_logs")
}

// Enums
enum UserRole {
  PLAYER
  MENTOR
  MODERATOR
  ADMIN
  SPONSOR
}

enum TeamRole {
  FOUNDER
  CO_FOUNDER
  DEVELOPER
  DESIGNER
  MARKETER
  ADVISOR
}

enum Difficulty {
  BRONZE
  SILVER
  GOLD
  BOSS
}

enum NodeType {
  QUIZ
  CODE
  DEPLOY
  CONTENT
  SOCIAL
  BOSS
  SPONSORED
}

enum SubmitterType {
  USER
  TEAM
}

enum SubmissionStatus {
  DRAFT
  SUBMITTED
  UNDER_REVIEW
  APPROVED
  REJECTED
  NEEDS_REVISION
}

enum ReviewStatus {
  PENDING
  COMPLETED
  DISPUTED
}

enum ChallengeType {
  TERRITORY
  SKILL
  COLLABORATION
}

enum ChallengeStatus {
  PENDING
  ACCEPTED
  DECLINED
  IN_PROGRESS
  JUDGING
  COMPLETED
  CANCELLED
}

enum ProgressStatus {
  LOCKED
  AVAILABLE
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum AgreementStatus {
  DRAFT
  PENDING_SIGNATURES
  ACTIVE
  AMENDED
  TERMINATED
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum SplitStatus {
  PROPOSED
  VOTING
  MEDIATION
  APPROVED
  REJECTED
  COMPLETED
}

enum SponsorTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum VerificationMethod {
  AUTOMATIC
  MANUAL
  HYBRID
}

enum RewardType {
  TOKEN
  NFT
  SERVICE
  PHYSICAL
}

enum RewardStatus {
  PENDING
  DISTRIBUTED
  CLAIMED
  EXPIRED
}

enum ExperienceLevel {
  JUNIOR
  MID
  SENIOR
  EXPERT
}

enum DisputeType {
  RESOURCE_ALLOCATION
  DECISION_MAKING
  EQUITY_SPLIT
  TEAM_SEPARATION
  BREACH_OF_AGREEMENT
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  APPROVED
  REJECTED
  CANCELLED
}

enum VoteType {
  APPROVE
  REJECT
  ABSTAIN
}

enum SeparationType {
  AMICABLE_SPLIT
  CONTESTED_SPLIT
  FOUNDER_EXIT
  MEMBER_REMOVAL
}

enum SeparationStatus {
  PENDING_VOTES
  APPROVED
  REJECTED
  EXECUTED
  CANCELLED
}

enum TokenTransactionType {
  TEAM_SEPARATION_DISTRIBUTION
  DISPUTE_RESOLUTION_PAYOUT
  PERFORMANCE_BONUS
  PENALTY_DEDUCTION
  TRADE
  STAKE
  UNSTAKE
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  FAILED
  CANCELLED
}

enum Currency {
  USD
  USDC
  SOL
}

enum SessionStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PaymentMethod {
  TOKENS
  CRYPTO
  FIAT
}

enum PaymentStatus {
  PENDING
  PAID
  REFUNDED
}

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum QuestStatus {
  ACTIVE
  COMPLETED
  ABANDONED
}

enum NotificationType {
  MISSION_COMPLETED
  TEAM_INVITATION
  CHALLENGE_RECEIVED
  MENTOR_SESSION
  SPONSOR_QUEST
  LEVEL_UP
  BADGE_EARNED
  TERRITORY_LOST
  CHARACTER_EVOLUTION
  RESOURCE_EARNED
  CRAFTING_COMPLETE
  STAKING_REWARD
}

// New enums for Character System
enum Kingdom {
  SILICON_VALLEY
  CRYPTO_VALLEY
  BUSINESS_STRATEGY
  PRODUCT_OLYMPUS
  MARKETING_MULTIVERSE
  ALL_KINGDOMS
}

enum CharacterClass {
  TECH_FOUNDER
  CRYPTO_FOUNDER
  BUSINESS_STRATEGIST
  PRODUCT_VISIONARY
  MARKETING_MAVERICK
  RENAISSANCE_FOUNDER
}

enum CharacterLevel {
  NOVICE          // Level 1-10
  APPRENTICE      // Level 11-25
  PRACTITIONER    // Level 26-40
  EXPERT          // Level 41-60
  MASTER          // Level 61-80
  GRANDMASTER     // Level 81-100
  LEGEND          // Level 100+
}

enum ResourceType {
  CODE_POINTS
  BUSINESS_ACUMEN
  MARKETING_INFLUENCE
  NETWORK_CONNECTIONS
  FUNDING_TOKENS
  DESIGN_CREATIVITY
  PRODUCT_VISION
}

enum EquipmentType {
  DEVELOPMENT_TOOLS
  BUSINESS_ARTIFACTS
  MARKETING_ASSETS
  NETWORK_TOOLS
  FUNDING_INSTRUMENTS
}

enum EquipmentRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum StakingPoolType {
  TERRITORY_CONTROL
  CHARACTER_DEVELOPMENT
  GUILD_TREASURY
  RESOURCE_GENERATION
}

// Character System Models
model FounderCharacter {
  id                    String   @id @default(cuid())
  userId                String   @unique
  honeycombCharacterId  String   @unique
  
  // Character Identity
  name                  String
  kingdom               Kingdom
  characterClass        CharacterClass
  level                 Int      @default(1)
  experience            Int      @default(0)
  experienceToNext      Int      @default(100)
  
  // Core Stats (0-1000 scale)
  technical             Int      @default(0)
  business              Int      @default(0)
  marketing             Int      @default(0)
  community             Int      @default(0)
  design                Int      @default(0)
  product               Int      @default(0)
  
  // Character Progression
  totalMissionsCompleted Int     @default(0)
  territoriesControlled  Int     @default(0)
  teamSize              Int      @default(1)
  reputationScore       Int      @default(0)
  
  // Visual Customization
  avatarUrl             String?
  kingdomEmblem         String?
  characterTheme        Json     @default("{}")
  
  // Game Mechanics
  isStaked              Boolean  @default(false)
  stakedUntil           DateTime?
  lastActiveBonus       DateTime @default(now())
  
  // Metadata
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  // Relationships
  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment             CharacterEquipment[]
  evolutions            CharacterEvolution[]
  stakingRecords        CharacterStake[]
  resourceInventory     UserResourceInventory[]
  
  @@map("founder_characters")
}

model CharacterEquipment {
  id                String   @id @default(cuid())
  characterId       String
  
  // Equipment Details
  name              String
  type              EquipmentType
  rarity            EquipmentRarity
  description       String
  
  // Equipment Effects
  statBoosts        Json     @default("{}")
  specialAbilities  Json     @default("[]")
  
  // Equipment State
  isEquipped        Boolean  @default(false)
  durability        Int      @default(100)
  level             Int      @default(1)
  
  // Acquisition
  acquiredFrom      String   // Mission, crafting, trade, etc.
  acquiredAt        DateTime @default(now())
  
  // NFT Integration
  nftMintAddress    String?
  nftMetadata       Json?
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  character         FounderCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  @@map("character_equipment")
}

model CharacterEvolution {
  id                String   @id @default(cuid())
  characterId       String
  
  // Evolution Details
  fromLevel         Int
  toLevel           Int
  evolutionType     String   // LEVEL_UP, SKILL_UNLOCK, CLASS_EVOLUTION
  
  // Stat Changes
  statChanges       Json     @default("{}")
  newAbilities      Json     @default("[]")
  
  // Evolution Trigger
  triggerType       String   // MISSION_COMPLETE, XP_THRESHOLD, SPECIAL_EVENT
  triggerData       Json     @default("{}")
  
  // Honeycomb Integration
  honeycombTxHash   String?
  onChainVerified   Boolean  @default(false)
  
  // Metadata
  evolvedAt         DateTime @default(now())
  
  // Relationships
  character         FounderCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  @@map("character_evolutions")
}

model UserResourceInventory {
  id                String   @id @default(cuid())
  userId            String
  characterId       String?
  
  // Resource Details
  resourceType      ResourceType
  amount            Int      @default(0)
  totalEarned       Int      @default(0)
  totalSpent        Int      @default(0)
  
  // Resource State
  isLocked          Boolean  @default(false)
  lockedAmount      Int      @default(0)
  lastEarned        DateTime?
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  character         FounderCharacter? @relation(fields: [characterId], references: [id])
  transactions      ResourceTransaction[]
  
  @@unique([userId, resourceType])
  @@map("user_resource_inventory")
}

model ResourceTransaction {
  id                String   @id @default(cuid())
  inventoryId       String
  
  // Transaction Details
  type              String   // EARNED, SPENT, TRADED, STAKED
  amount            Int
  description       String
  
  // Transaction Source
  sourceType        String   // MISSION, CRAFTING, TRADE, STAKING
  sourceId          String?
  
  // Transaction Context
  missionId         String?
  craftingId        String?
  tradeId           String?
  stakingId         String?
  
  // Honeycomb Integration
  honeycombTxHash   String?
  onChainVerified   Boolean  @default(false)
  
  // Metadata
  createdAt         DateTime @default(now())
  
  // Relationships
  inventory         UserResourceInventory @relation(fields: [inventoryId], references: [id], onDelete: Cascade)
  
  @@map("resource_transactions")
}

model CraftingRecipe {
  id                String   @id @default(cuid())
  
  // Recipe Details
  name              String   @unique
  description       String
  category          String   // MVP, PITCH_DECK, BUSINESS_PLAN, etc.
  
  // Requirements
  requiredResources Json     // { "CODE_POINTS": 100, "BUSINESS_ACUMEN": 50 }
  requiredLevel     Int      @default(1)
  requiredKingdom   Kingdom?
  
  // Output
  resultType        String   // EQUIPMENT, CONSUMABLE, UPGRADE
  resultMetadata    Json     @default("{}")
  
  // Crafting Mechanics
  craftingTime      Int      @default(0) // seconds
  successRate       Float    @default(1.0)
  maxAttempts       Int?
  
  // Availability
  isActive          Boolean  @default(true)
  unlockConditions  Json     @default("{}")
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  craftingJobs      CraftingJob[]
  
  @@map("crafting_recipes")
}

model CraftingJob {
  id                String   @id @default(cuid())
  userId            String
  recipeId          String
  
  // Job Status
  status            String   @default("IN_PROGRESS") // IN_PROGRESS, COMPLETED, FAILED, CANCELLED
  startedAt         DateTime @default(now())
  completedAt       DateTime?
  
  // Job Details
  resourcesSpent    Json     @default("{}")
  resultReceived    Json?
  
  // Progress
  progressPercent   Int      @default(0)
  currentStep       String?
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipe            CraftingRecipe @relation(fields: [recipeId], references: [id])
  
  @@map("crafting_jobs")
}

model StakingPool {
  id                String   @id @default(cuid())
  
  // Pool Identity
  name              String   @unique
  description       String
  poolType          StakingPoolType
  
  // Staking Mechanics
  stakingAsset      String   // CHARACTERS, RESOURCES, TERRITORIES
  rewardAsset       String   // XP, RESOURCES, TOKENS
  
  // Pool Parameters
  minimumStake      Int      @default(1)
  stakingPeriod     Int      @default(86400) // seconds
  rewardRate        Float    @default(0.1)   // 10% annual
  compoundingRate   String   @default("DAILY")
  
  // Pool Limits
  maxStakers        Int?
  maxTotalStaked    Int?
  
  // Pool State
  isActive          Boolean  @default(true)
  totalStaked       Int      @default(0)
  totalStakers      Int      @default(0)
  totalRewardsPaid  Int      @default(0)
  
  // Pool Lifecycle
  startDate         DateTime @default(now())
  endDate           DateTime?
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  stakes            CharacterStake[]
  
  @@map("staking_pools")
}

model CharacterStake {
  id                String   @id @default(cuid())
  poolId            String
  characterId       String
  
  // Stake Details
  amountStaked      Int
  stakedAt          DateTime @default(now())
  unlockAt          DateTime
  
  // Reward Tracking
  rewardsEarned     Int      @default(0)
  lastRewardClaim   DateTime?
  compoundedRewards Int      @default(0)
  
  // Stake State
  isActive          Boolean  @default(true)
  isUnstaked        Boolean  @default(false)
  unstakedAt        DateTime?
  
  // Honeycomb Integration
  honeycombStakeId  String?
  onChainVerified   Boolean  @default(false)
  
  // Metadata
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  // Relationships
  pool              StakingPool @relation(fields: [poolId], references: [id], onDelete: Cascade)
  character         FounderCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  
  @@unique([poolId, characterId])
  @@map("character_stakes")
}